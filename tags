!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/malifpy/Alif/Git/TBuFalO/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	/p5.9.20210905.0/
BIN	CFG2CNF.py	/^def BIN(productions, variables):$/;"	f
CFG	cfg_to_cnf.py	/^    CFG = clean(file)$/;"	v
CNF	cfg_to_cnf.py	/^CNF = []$/;"	v
DEL	CFG2CNF.py	/^def DEL(productions):$/;"	f
K	CFG2CNF.py	/^	K, V, Productions = helper.loadModel( modelPath )$/;"	v
K	CFG2CNF.py	/^K, V, Productions = [],[],[]$/;"	v
Lexer	lexer.py	/^class Lexer(object):$/;"	c
Productions	CFG2CNF.py	/^	K, V, Productions = helper.loadModel( modelPath )$/;"	v
Productions	CFG2CNF.py	/^	Productions = BIN(Productions, variables=V)$/;"	v
Productions	CFG2CNF.py	/^	Productions = DEL(Productions)$/;"	v
Productions	CFG2CNF.py	/^	Productions = START(Productions, variables=V)$/;"	v
Productions	CFG2CNF.py	/^	Productions = TERM(Productions, variables=V)$/;"	v
Productions	CFG2CNF.py	/^	Productions = UNIT(Productions, variables=V)$/;"	v
Productions	CFG2CNF.py	/^K, V, Productions = [],[],[]$/;"	v
START	CFG2CNF.py	/^def START(productions, variables):$/;"	f
TBuFalO	README.md	/^# TBuFalO$/;"	c
TERM	CFG2CNF.py	/^def TERM(productions, variables):$/;"	f
UNIT	CFG2CNF.py	/^def UNIT(productions, variables):$/;"	f
V	CFG2CNF.py	/^	K, V, Productions = helper.loadModel( modelPath )$/;"	v
V	CFG2CNF.py	/^K, V, Productions = [],[],[]$/;"	v
__init__	lexer.py	/^    def __init__(self, rules):$/;"	m	class:Lexer
clean	cfg_to_cnf.py	/^def clean(fileName):$/;"	f
cleanAlphabet	helper.py	/^def cleanAlphabet(expression):$/;"	f
cleanProduction	helper.py	/^def cleanProduction(expression):$/;"	f
dict2Set	helper.py	/^def dict2Set(dictionary):$/;"	f
file	cfg_to_cnf.py	/^    file = open(fileName).read()$/;"	v
file	lexer.py	/^            file = open(filename)$/;"	v
fileName	cfg_to_cnf.py	/^    fileName = 'grammar\/cfg.txt'$/;"	v
filename	lexer.py	/^            filename = input("Nama File: ")$/;"	v
isSimple	CFG2CNF.py	/^def isSimple(rule):$/;"	f
isUnitary	CFG2CNF.py	/^def isUnitary(rule, variables):$/;"	f
left	CFG2CNF.py	/^left, right = 0, 1$/;"	v
left	helper.py	/^left, right = 0, 1$/;"	v
loadModel	helper.py	/^def loadModel(modelPath):$/;"	f
lx	lexer.py	/^    lx = Lexer(rule.lx_rules)$/;"	v
lx_rules	lexer_rules.py	/^lx_rules = [$/;"	v
mode	lexer.py	/^        mode = input("Pilih Mode: ")$/;"	v
mode	lexer.py	/^    mode = ""$/;"	v
modelPath	CFG2CNF.py	/^		modelPath = str(sys.argv[1])$/;"	v
pprintRules	helper.py	/^def pprintRules(rules):$/;"	f
prettyForm	helper.py	/^def prettyForm(rules):$/;"	f
re	lexer.py	/^import regex as re$/;"	I	nameref:module:regex
rewrite	helper.py	/^def rewrite(target, production):$/;"	f
right	CFG2CNF.py	/^left, right = 0, 1$/;"	v
right	helper.py	/^left, right = 0, 1$/;"	v
rule	lexer.py	/^import lexer_rules as rule$/;"	I	nameref:module:lexer_rules
seekAndDestroy	helper.py	/^def seekAndDestroy(target, productions):$/;"	f
setupDict	helper.py	/^def setupDict(productions, variables, terms):$/;"	f
toString	lexer.py	/^    def toString(self, text):$/;"	m	class:Lexer
toToken	lexer.py	/^    def toToken(self, text):$/;"	m	class:Lexer
token_parser	lexer.py	/^    def token_parser(self, text):$/;"	m	class:Lexer
txt	lexer.py	/^                txt = input("> ")$/;"	v
txt	lexer.py	/^            txt = ""$/;"	v
txt	lexer.py	/^            txt = file.read()$/;"	v
union	helper.py	/^def union(lst1, lst2):$/;"	f
unit_routine	CFG2CNF.py	/^def unit_routine(rules, variables):$/;"	f
variablesJar	CFG2CNF.py	/^variablesJar =  ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P",/;"	v
